<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manage Announcements</title>
    <link rel="stylesheet" href="/static/css/bootstrap.css">
    <script src="/static/js/bootstrap.js"></script>
    <style>
        body { background-color: #f8f9fa; }
        #editorContainer { display:none; flex-direction:column; align-items:center; gap:10px; }
        canvas { border:1px solid #ccc; cursor:crosshair; image-rendering:pixelated; }
        .toolbar { display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
        .text-toolbox { display:none; margin-top:10px; justify-content:center; gap:10px; }
        .preview-img { image-rendering:pixelated; border:1px solid #ccc; width:100%; }
        #activeColor { width:20px; height:20px; border:1px solid #000; display:inline-block; vertical-align:middle; }
        #editBanner { display:none; margin:10px 0; padding:5px 10px; background:#ffeeba; border:1px solid #f0ad4e; border-radius:4px; }
        #displaySelectorBox { margin-bottom: 1rem; }
    </style>
</head>
<body class="container mt-4">
<h1 class="mb-4">Manage Announcements</h1>

<!-- Edit Mode Banner -->
<div id="editBanner">
    <span>Editing announcement <strong id="editingId"></strong> (<span id="editingVisibleState"></span>)</span>
    <button class="btn btn-sm btn-outline-secondary ms-2" onclick="toggleVisibility()">Toggle Visible</button>
    <button class="btn btn-sm btn-outline-danger ms-2" onclick="exitEditMode()">Exit Edit Mode</button>
</div>

<!-- Display Selector -->
<div id="displaySelectorBox">
    <label class="form-label">Select Display:</label>
    <select class="form-select" onchange="initEditor(this.value)">
        <option value="">-- choose display --</option>
        {% for display in displays %}
        <option value="{{ display.name }}">{{ display.name }}</option>
        {% endfor %}
    </select>
</div>

<!-- Pixel Editor -->
<div id="editorContainer">
    <div style="position: relative;">
        <canvas id="pixelCanvas"></canvas>
        <canvas id="gridCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
    </div>

    <!-- Main Toolbar -->
    <div class="toolbar">
        <button class="btn btn-sm btn-outline-primary" onclick="setTool('pencil')">Pen</button>
        <button class="btn btn-sm btn-outline-danger" onclick="setTool('erase')">Eraser</button>
        <button class="btn btn-sm btn-outline-secondary" onclick="toggleTextToolbox()">Add Text</button>
        <button class="btn btn-sm btn-outline-dark" onclick="fillCanvas()">Fill</button>
        <button class="btn btn-sm btn-outline-warning" onclick="clearCanvas()">Clear</button>

        <!-- Color UI -->
        <input type="color" id="colorPicker" style="display:none;" value="#000000" onchange="setActiveColor(this.value)">
        <div id="activeColor"></div>

        <label class="form-check-label ms-2">
            <input type="checkbox" id="toggleGrid" onchange="drawGrid()" checked> Show Grid
        </label>

        <input id="orderField" type="number" class="form-control form-control-sm ms-2" placeholder="Order" style="width:80px;" value="0">
        <button class="btn btn-success btn-sm ms-2" onclick="saveAnnouncement(true)">Save</button>
    </div>

    <!-- Text Toolbox -->
    <div class="text-toolbox" id="textToolbox">
        <input type="text" id="textInput" placeholder="Text" class="form-control form-control-sm" style="width:120px;">
        <select id="fontSelect" class="form-select form-select-sm" style="width:120px;">
            <option value="sans-serif">Sans</option>
            <option value="serif">Serif</option>
            <option value="monospace">Monospace</option>
            <option value="cursive">Cursive</option>
        </select>
        <input type="number" id="textSize" value="8" class="form-control form-control-sm" style="width:60px;" title="Font size">
        <select id="textWeight" class="form-select form-select-sm" style="width:90px;">
            <option value="normal">Normal</option>
            <option value="bold">Bold</option>
        </select>
        <input type="number" id="textX" placeholder="X" class="form-control form-control-sm" style="width:50px;">
        <input type="number" id="textY" placeholder="Y" class="form-control form-control-sm" style="width:50px;">
        <button class="btn btn-sm btn-outline-success" onclick="applyText()">Apply</button>
    </div>

    <!-- Base64 Editor -->
    <div class="mt-3" style="width:100%">
        <label for="base64Field" class="form-label">Base64 Data:</label>
        <textarea id="base64Field" class="form-control" rows="3" style="font-family: monospace;"></textarea>
        <div class="mt-2">
            <button class="btn btn-outline-primary btn-sm" onclick="previewBase64()">Preview</button>
            <button class="btn btn-outline-success btn-sm" onclick="saveAnnouncement(true)">Save from Base64</button>
        </div>
    </div>
</div>

<!-- Existing Announcements -->
<h3 class="mt-5">Existing Announcements</h3>
<table class="table table-striped">
    <thead>
    <tr>
        <th>For Display</th>
        <th>Order</th>
        <th>Visible</th>
        <th>Preview</th>
        <th>Actions</th>
    </tr>
    </thead>
    <tbody>
    {% for ann in announcements %}
    <tr>
        <td>{{ ann.for_display }}</td>
        <td>{{ ann['order'] }}</td>
        <td>{{ "Visible" if ann.visible in (True, 1, '1') else "Hidden" }}</td>
        <td><img class="preview-img" src="data:image/png;base64,{{ ann['data'] }}" alt="Preview"></td>
        <td>
            <button class="btn btn-primary btn-sm"
              onclick="editAnnouncement({{ ann.id }}, '{{ ann.for_display }}', '{{ ann['data'] }}', {{ 'true' if ann.visible in (True,1,'1') else 'false' }})">
              Edit
            </button>
            <button class="btn btn-danger btn-sm" onclick="deleteAnnouncement({{ ann.id }})">Delete</button>
        </td>
    </tr>
    {% endfor %}
    </tbody>
</table>

<script>
const displays = {{ displays|tojson }};
let currentDisplay = null;
let pixels = [];
let resolution = [0,0];
let zoom = 10;
let currentTool = 'pencil';
let currentColor = '#000000';
let isMouseDown = false;
let editingId = null;
let editingVisible = true;

function initEditor(displayName) {
    currentDisplay = displays.find(d => d.name === displayName);
    resolution = currentDisplay.resolution;

    const canvas = document.getElementById("pixelCanvas");
    const gridCanvas = document.getElementById("gridCanvas");
    canvas.width = resolution[0] * zoom;
    canvas.height = resolution[1] * zoom;
    gridCanvas.width = canvas.width;
    gridCanvas.height = canvas.height;

    pixels = Array.from({ length: resolution[1] }, () => Array(resolution[0]).fill(0));

    document.getElementById("colorPicker").style.display = currentDisplay.color ? 'inline-block' : 'none';
    setActiveColor('#000000');

    drawCanvas();
    drawGrid();
    document.getElementById("editorContainer").style.display = "flex";
}

function setTool(tool) { currentTool = tool; }
function setActiveColor(color) {
    currentColor = color;
    document.getElementById("activeColor").style.background = color;
}

document.addEventListener('mousedown', () => isMouseDown = true);
document.addEventListener('mouseup', () => isMouseDown = false);
document.addEventListener('mousemove', (e) => {
    if (!isMouseDown) return;
    if (currentTool === 'pencil') drawPixelAtEvent(e);
    else if (currentTool === 'erase') erasePixelAtEvent(e);
});

document.getElementById("pixelCanvas").addEventListener('mousedown', (e) => {
    if (currentTool === 'pencil') drawPixelAtEvent(e);
    else if (currentTool === 'erase') erasePixelAtEvent(e);
});

function drawPixelAtEvent(event) {
    const rect = event.target.getBoundingClientRect();
    const x = Math.floor((event.clientX - rect.left) / zoom);
    const y = Math.floor((event.clientY - rect.top) / zoom);
    if (x>=0 && y>=0 && x<resolution[0] && y<resolution[1]) {
        pixels[y][x] = currentDisplay.color ? currentColor : 1;
        drawCanvas();
    }
}
function erasePixelAtEvent(event) {
    const rect = event.target.getBoundingClientRect();
    const x = Math.floor((event.clientX - rect.left) / zoom);
    const y = Math.floor((event.clientY - rect.top) / zoom);
    if (x>=0 && y>=0 && x<resolution[0] && y<resolution[1]) {
        pixels[y][x] = 0;
        drawCanvas();
    }
}

function toggleTextToolbox() {
    const box = document.getElementById("textToolbox");
    box.style.display = box.style.display === "flex" ? "none" : "flex";
}

function applyText() {
    const text = document.getElementById("textInput").value || "Text";
    const size = parseInt(document.getElementById("textSize").value, 10) || 8;
    const weight = document.getElementById("textWeight").value;
    const font = document.getElementById("fontSelect").value;
    const x = parseInt(document.getElementById("textX").value, 10) || 0;
    const y = parseInt(document.getElementById("textY").value, 10) || 0;
    const inverse = false;

    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = resolution[0];
    tempCanvas.height = resolution[1];
    const ctx = tempCanvas.getContext("2d");

    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    ctx.font = `${weight} ${size}px ${font}`;
    ctx.fillStyle = "#FFFFFF";
    ctx.textBaseline = "top";
    ctx.fillText(text, x, y);

    const imgData = ctx.getImageData(0, 0, resolution[0], resolution[1]).data;

    for (let yy = 0; yy < resolution[1]; yy++) {
        for (let xx = 0; xx < resolution[0]; xx++) {
            const idx = (yy * resolution[0] + xx) * 4;
            const val = imgData[idx]; // red channel
            const on = val > 100 ? 1 : 0;

            if (on) {
                pixels[yy][xx] = inverse ? 0 : 1;
            }
        }
    }

    drawCanvas();
}

function fillCanvas() {
    for (let y=0; y<resolution[1]; y++) {
        for (let x=0; x<resolution[0]; x++) {
            pixels[y][x] = currentDisplay.color ? currentColor : 1;
        }
    }
    drawCanvas();
}

function clearCanvas() {
    for (let y=0; y<resolution[1]; y++) {
        for (let x=0; x<resolution[0]; x++) {
            pixels[y][x] = 0;
        }
    }
    drawCanvas();
}

function drawCanvas() {
    const canvas = document.getElementById("pixelCanvas");
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let y=0; y<resolution[1]; y++) {
        for (let x=0; x<resolution[0]; x++) {
            const val = pixels[y][x];
            ctx.fillStyle = currentDisplay.color ? (val || '#FFFFFF') : (val ? '#000000' : '#FFFFFF');
            ctx.fillRect(x*zoom, y*zoom, zoom, zoom);
        }
    }
    updateBase64Field();
}

function drawGrid() {
    const gridCanvas = document.getElementById("gridCanvas");
    const ctx = gridCanvas.getContext("2d");
    ctx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

    if (!document.getElementById("toggleGrid").checked) return;

    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    for (let x=0; x<=resolution[0]; x++) {
        ctx.beginPath();
        ctx.moveTo(x*zoom, 0);
        ctx.lineTo(x*zoom, resolution[1]*zoom);
        ctx.stroke();
    }
    for (let y=0; y<=resolution[1]; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y*zoom);
        ctx.lineTo(resolution[0]*zoom, y*zoom);
        ctx.stroke();
    }
}

function exportBase64() {
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = resolution[0];
    tempCanvas.height = resolution[1];
    const ctx = tempCanvas.getContext("2d");

    for (let y=0; y<resolution[1]; y++) {
        for (let x=0; x<resolution[0]; x++) {
            const val = pixels[y][x];
            ctx.fillStyle = currentDisplay.color ? (val || '#FFFFFF') : (val ? '#000000' : '#FFFFFF');
            ctx.fillRect(x, y, 1, 1);
        }
    }

    return tempCanvas.toDataURL("image/png").split(",")[1];
}

function updateBase64Field() {
    document.getElementById("base64Field").value = exportBase64();
}

function previewBase64() {
    const base64 = document.getElementById("base64Field").value.trim();
    if (!base64) {
        alert("Base64 field is empty");
        return;
    }
    const img = new Image();
    img.onload = function() {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = resolution[0];
        tempCanvas.height = resolution[1];
        const ctx = tempCanvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        const data = ctx.getImageData(0, 0, resolution[0], resolution[1]).data;
        for (let y = 0; y < resolution[1]; y++) {
            for (let x = 0; x < resolution[0]; x++) {
                const i = (y * resolution[0] + x) * 4;
                if (data[i+3] > 0) {
                    if (currentDisplay.color) {
                        pixels[y][x] = `rgb(${data[i]},${data[i+1]},${data[i+2]})`;
                    } else {
                        pixels[y][x] = (data[i] < 200 || data[i+1] < 200 || data[i+2] < 200) ? 1 : 0;
                    }
                } else {
                    pixels[y][x] = 0;
                }
            }
        }
        drawCanvas();
    };
    img.src = "data:image/png;base64," + base64;
}

async function saveAnnouncement(isNew, id=null) {
    const base64 = exportBase64();
    const forDisplay = currentDisplay.name;
    const order = parseInt(document.getElementById("orderField").value,10);

    const payload = { for_display: forDisplay, order: order, data: base64, visible: editingVisible };

    const url = isNew ? "/api/display/announcements" : `/api/display/announcements/${id}`;

    const resp = await fetch(url, {
        method: isNew ? "POST" : "PUT",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
    });

    if (resp.ok) location.reload();
    else alert("Error saving announcement");
}

function editAnnouncement(id, displayName, base64, visible) {
    initEditor(displayName);

    document.getElementById("displaySelectorBox").style.display = "none";
    editingId = id;
    editingVisible = visible;

    document.getElementById("editBanner").style.display = "block";
    document.getElementById("editingId").textContent = id;
    document.getElementById("editingVisibleState").textContent = visible ? "Visible" : "Hidden";
    document.querySelector(".btn-success").setAttribute("onclick", `saveAnnouncement(false, ${id})`);

    previewBase64FromData(base64);
}

function previewBase64FromData(base64) {
    const img = new Image();
    img.onload = function() {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = resolution[0];
        tempCanvas.height = resolution[1];
        const ctx = tempCanvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        const data = ctx.getImageData(0, 0, resolution[0], resolution[1]).data;
        for (let y = 0; y < resolution[1]; y++) {
            for (let x = 0; x < resolution[0]; x++) {
                const i = (y * resolution[0] + x) * 4;
                if (data[i+3] > 0) {
                    if (currentDisplay.color) {
                        pixels[y][x] = `rgb(${data[i]},${data[i+1]},${data[i+2]})`;
                    } else {
                        pixels[y][x] = (data[i] < 200 || data[i+1] < 200 || data[i+2] < 200) ? 1 : 0;
                    }
                } else {
                    pixels[y][x] = 0;
                }
            }
        }
        drawCanvas();
    };
    img.src = "data:image/png;base64," + base64;
}

function toggleVisibility() {
    editingVisible = !editingVisible;
    document.getElementById("editingVisibleState").textContent = editingVisible ? "Visible" : "Hidden";
}

function exitEditMode() {
    editingId = null;
    editingVisible = true;
    document.getElementById("editBanner").style.display = "none";
    document.getElementById("displaySelectorBox").style.display = "block";
    document.querySelector(".btn-success").setAttribute("onclick", `saveAnnouncement(true)`);
}

async function deleteAnnouncement(id) {
    if (!confirm("Delete this announcement?")) return;
    const resp = await fetch(`/api/display/announcements/${id}`, { method: "DELETE" });
    if (resp.ok) location.reload();
    else alert("Error deleting announcement");
}
</script>
</body>
</html>

